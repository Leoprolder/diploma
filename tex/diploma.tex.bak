\documentclass[14pt,a4paper,twosided]{extreport}%размер бумаги - А4, шрифт - 14, класс документа - отчет
\usepackage[cp1251]{inputenc}%кодировка символов:koi8-r или utf8 в UNIX, cp1251 в Windows
\usepackage[english,russian]{babel}%используем русский и английский языки с переносами
\usepackage{DiplomaSUSU}%оформляем согласно нормоконтролю дипломных работ студентов кафедры математического и компьютерного моделирования ЮУрГУ

\begin{document}

\input{title}

\newpage

\setcounter{page}{2}
\input{summary}

\newpage

\newpage
\renewcommand{\contentsname}{ \begin{center} ОГЛАВЛЕНИЕ \end{center}  }%размер, положение и название оглавления
\tableofcontents%команда автоматической генерации оглавления
\newpage

\chapter*{Введение}\addcontentsline{toc}{section}{\hspace{-0.9cm}ВЕДЕНИЕ }
Одним из популярных способов заработка является покупка-продажа акций на биржах. Это относительно простой способ на первый взгляд, но при ближайшем знакомстве становится понятно, что во многом всё зависит от статистики. Исследуя закономерности изменения прошлых изменений стоимости акций можно принимать решения о покупке-продаже в тот или иной момент. Но собирать данные вручную очень долгий и трудоёмкий процесс. Поэтому существуют решения на платформах наподобие Investing.com \cite{Inet source1} со своим собственным анализом данных.

Целью данной работы является построение прогноза динамики изменения цен на акции компании «Samsung Electronics Co.». В качестве источника данных рассматривается Лондонская биржа, цены на которой представлены в USD.

Декомпозируем задачу. Для достижения вышеобозначенной цели необходимо решить следующие подзадачи:
\begin{enumerate}
\item провести обзор имеющихся методов прогнозирования;
\item выбрать наиболее подходящий метод;
\item собрать данные;
\item построить прогноз по имеющимся данным.
\end{enumerate}

Задача о сборе данных и построение на их основе прогноза представляет собой ещё одну композицию. Для её решения будет разработано приложение, решающее следующие проблемы:
\begin{enumerate}
\item проектирование структуры приложения;
\item разработка жизненного цикла программы;
\item разработка алгоритма работы;
\item получение актуальной информации с сайта Investing.com в режиме реального времени;
\item запись и последующее чтение полученной информации в файл для оптимизации памяти и возможности выполнения своих функций даже после перезапуска;
\item реализация выбранных методов прогнозирования;
\item разработка пользовательского интерфейса программы;
\item вывод полученных и обработанных данных.
\end{enumerate}

В первой главе будет рассмотрена общая информация об акциях, биржах и их различиях, а также рассмотрим подробнее существующие методы для прогнозирования данных, определив методы, которые будут использованы в этой работе.

Вторая глава включит в себя разработку приложения, соответствующее обозначенным выше требованиям. В этом разделе будет рассмотрен процесс проектирования приложения, построения его алгоритма, разработки необходимых модулей и решения задачи пользовательского интерфейса. Также будут рассмотрены библиотеки, решающие те или иные задачи.

В третьей главе будут представлены результаты работы выбранных методов анализа и прогнозирования собранных данных.

\zerocounters
\chapter*{\thechapter. Общая информация и методы анализа данных}\addcontentsline{toc}{section}{\hspace{-1.2cm} \thechapter. ОБЩАЯ ИНФОРМАЦИЯ И МЕТОДЫ АНАЛИЗА ДАННЫХ }
\section{Информация о компании «Samsung Electronics Co.»}
«Samsung Electronics Co.» является частью южнокорейской группы компаний Samsung Group, известной во всём мире как крупнейший производитель электроники. Ежегодно компания достигает отметки в более чем 400 миллионов проданных мобильных устройств, которые являются большей частью прибыли компании. Такие высокие продажи обусловлены высоким уровнем качества и технологий в выпускаемых продуктах.

Кроме производства уже готовых устройств, компания производит также комплектующие на продажу, такие как:
 \begin{enumerate}
 \item дисплеи, выполненные по технологии OLED и AMOLED, на которые «Samsung Electronics Co.» имеет эксклюзивные права;
 \item NAND флеш-память;
 \item литиево-ионные аккумуляторы и прочее;
 \end{enumerate}

 Компания является крупным поставщиком для таких компаний как Sony, Apple, Dell, Hewlett-Packard и других крупных компаний.

 Таким образом, «Samsung Electronics Co.» является одной из самых крупнейших компаний, не только производящей мобильные устройства, но и комплектующие для собственных нужд и на продажу прочим большим игрокам на рынке, что и обеспечивает высокую стоимость акций, год от года показывающих неуклонный рост.
\section{Информация об акциях}%section

\subsection{Категории акций}
Прежде чем рассматривать методы анализа данных и приступать к их реализации, рассмотрим, какие бывают акции и чем они отличаются:
\begin{enumerate}
\item Обыкновенные акции дают право на участие в управленческих процессах общества (как правило, одна акция соответствует одному голосу на собрании акционеров, кроме проведения кумулятивного голосования) и участвуют в распределении полученной прибыли акционерного общества. Источником для выплаты дивидендов по таким акциям является чистая прибыль общества. Размер самих дивидендов определяется советом директоров предприятия и рекомендуется собранию акционеров, которое способно только уменьшить или оставить неизменным размер дивидендов относительно рекомендованного советом директоров. Распределение дивидендов владельцев обыкновенных акций между собой осуществляется пропорционально вложенным средствам (в зависимости от количества приобретённых акций).
\item Привилегированные акции имеют право вносить ограничения на участие в управленческих процессах, а также могут давать дополнительные права в управлении, но по сравнению с обыкновенными акциями имеют ряд преимуществ: возможность получения гарантированного дохода, внеочерёдное выделение прибыли на выплату дивидендов, внеочерёдное погашение стоимости акции при ликвидации общества. Дивиденды, как правило, фиксированы в виде определённой доли от бухгалтерской чистой прибыли или в абсолютном денежном значении. Дивиденды по привилегированным акциям могут выплачиваться как из прибыли, так и из других источников — в соответствии с уставом акционерного общества. Привилегированные акции делятся на:
    \begin{enumerate}
    \item Привилегированные имеют ряд привилегий в обмен на право голоса. У их собственника определена величина дохода в момент выпуска и размещения ценных бумаг. Также у таких акций определён размер ликвидационной стоимости. Приоритет при переводе этих начислений по отношению к обыкновенным.
    \item Кумулятивные (накапливающие). Привилегии — как у привилегированных. Сохраняется и обязательство по выплате дивидендов и оно же накапливается. Срок накопления дивидендов фиксирован. При невыплате дивидендов обладатели этого вида акций получают право голоса до выплаты дивидендов.
    \end{enumerate}
\end{enumerate}

Аналог привилегированных акций — учредительская акция — акция, распространяемая среди учредителей акционерных компаний и дающая им некоторые преимущественные права. Держатели таких акций имеют возможность:
\begin{enumerate}
\item иметь дополнительное количество голосов во время собрания акционеров;
\item пользоваться внеочередным правом на получение акций в случае их последующих эмиссий;
\item играть главную роль в решении любых всех вопросов, которые связаны с деятельностью акционерных компаний.
\end{enumerate}

По именным акциям данные об их владельцах регистрируются в реестре акционерного общества. В соответствии с законодательством физические и юридические лица могут быть владельцами именных акций.

Акции на предъявителя допускают их свободную куплю-продажу на вторичном рынке без необходимости перерегистрации владельца. Российское законодательство допускало выпуск акций на предъявителя до 2002 года. С 2003 года акции могут выпускаться только в форме именной ценной бумаги.

\subsection{Стоимость акций}

Различают разные виды стоимости акций:

\begin{enumerate}
\item{Номинальная стоимость акции — это то, что указано на её лицевой стороне (иногда её называют нарицательной стоимостью). Общая величина уставного капитала равна общей сумме номиналов всех выпущенных акций.

Номинальная стоимость всех обыкновенных акций общества должна быть одинаковой.

Номинальная стоимость не обязана отражать реальную ценность акций. Однако она часто используется для ряда операций (оценка пошлин, комиссий, тарифов), особенно на неразвитом, малоликвидном фондовом рынке. Цена акций при первичном размещении не должна быть ниже номинальной стоимости.}
\item{Эмиссионная стоимость акции — стоимость акций при их первичном размещении, по которой её приобретает первый держатель. Обычно эмиссионная цена акции превышает номинальную стоимость или равна ей. Превышение эмиссионной цены над номинальной стоимостью называется эмиссионной выручкой, или эмиссионным доходом.}
\item{Балансовая стоимость акций — частное от деления стоимости чистых активов компании (балансовой стоимости компании) на количество выпущенных акций, находящихся в обращении. Если рыночная цена ниже балансовой, то это является основой для будущего биржевого роста цены. Обычно балансовую стоимость определяют при аудиторских проверках.}
\item{Рыночная стоимость акции — это цена, по которой акция продаётся и покупается на вторичном рынке. Рыночная цена (котировка, курс) обычно формируется на торгах на фондовой бирже и отражает баланс спроса и предложения на данные акции. Для формирования рыночной цены важное значение имеет уровень ликвидности фондового рынка. Косвенно, рыночная стоимость акций отражает ликвидационную стоимость активов и пассивов компании.}
\end{enumerate}

\section{Общие сведения о биржах}%section
Фондовая биржа — это финансовый институт, обеспечивающий регулярное функционирование организованного рынка ценных бумаг.

В каждой стране мира с рыночной экономикой есть национальная фондовая биржа. Это организованный рынок для торговли ценными бумагами: акциями, облигациями и другими финансовыми инструментами.

Для допуска к торгам на бирже акции должны пройти процедуру листинга или быть допущены к торгам без прохождения процедуры листинга.

Участие акции в торгах позволяет эмитенту привлечь самый дешёвый и самый долгосрочный капитал, повысить стоимость компании, снизить стоимость заимствований, поднять свой престиж, осуществлять дополнительную рекламу через биржевые каналы и успешно размещать последующие выпуски.

В данной работе будут рассматриваться биржи NASDAQ (сокр. от англ. National Association of Securities Dealers Automated Quotation, читается как «Насдак» — Автоматизированные котировки Национальной ассоциации дилеров по ценным бумагам) — американская биржа, специализирующаяся на акциях высокотехнологичных компаний (производство электроники, программного обеспечения и т. п.) и корейская биржа (англ. Korea Exchange, KRX) — крупнейшая в мире биржа по объему сделок с деривативами.

\section{Обзор методов прогнозирования данных}

Технический анализ – наиболее распространенный вид анализа валютного рынка. Он дарит ощущение полного контроля в прогнозах торгующего человека. Его суть заключается в анализе прошлого, таким образом трейдеры анализируют прошлые котировки и уровни цены, и на основе этого делают выводы о будущем.

Методология заключается в сборе данных и восстановлении ряда по определённым правилам. Таким образом, описав правило, по которому мы восстанавливаем значения ряда на основе предыдущих его значений, можно перейти к прогнозированию ряда и выявить общую закономерность образования новых данных.

Так как наше приложение свободно манипулирует большим количеством текущих и прошлых данных, этот вид анализа наиболее подходящий.

\subsection{Простое скользящее среднее}

Метод простого скользящего среднего (MA) основан на выборе некоторого числа последних элементов и подсчёте их среднего арифметического. Такое число считается следующим порядковым числом, идущим за выборкой. Модель скользящего среднего порядка q обозначается MA(q) и записывается следующим образом:

$$ X_t = \sum^{q}_{i=1}{\theta_i\varepsilon_{t-i} + \varepsilon_t}, $$

где $\theta_1, ..., \theta_q - $ параметры модели, а $\varepsilon_t, ..., \varepsilon_{t-q} - $ ошибки.

Данный метод является очень простым в программной реализации и уже реализован во многих подключаемых пакетах. Несмотря на этот факт, метод даёт значения весьма близкие к действительным. Также метод простого скользящего среднего используется платформой Investing.com в качестве базового метода для прогнозирования будущих цен акций.

Тем не менее, несмотря на преимущества метода, он не позволяет построить достаточно точную модель, описывающую динамику поведения ряда в будущем, показывая себя лучше на точечных значениях, основанных на предыдущих значениях ряда ~\cite{Book2}.

\subsection{Авторегрессионное скользящее среднее}

Авторегрессионное скользящее среднее (ARMA), также называемая иногда моделью Бокса-Дженкинса, является объединением двух моделей исследования временных рядов: авторегрессионной (AR) и модели простого скользящего среднего (MA). Под обозначением ARMA(p,q) понимается модель, содержащая p авторегрессионных составляющих и q скользящих средних. Точнее модель ARMA(p,q) включает в себя модели AR(p) и MA(q) ~\cite{Inet source3}:

$$ X_t = с + \sum^{q}_{i=1}{\theta_i\varepsilon_{t-i}} + \sum^{p}_{i=1}{\phi_i X_{t-i}}, $$

где $\phi_1, ..., \phi_p - $ параметры авторегрессионной модели, а $c -$ константа. Для простоты константу, как правило, опускают.

Как правило, в качестве значения ошибки $\varepsilon_t$ берут нормально случайные величины с нулевым средним: $\varepsilon_t \sim N(0,\sigma^2)$, где $\sigma^2$ – дисперсия ~\cite{Book3}.

Метод является улучшенным вариантом метода простого скользящего среднего и корректирует получаемые средние значения на основе авторегрессии ряда. Метод позволяет получать более точные точечные значения, но также, как и предыдущий, не позволяет рассмотреть динамику ряда в достаточно большой перспективе с необходимой точностью.

\section{Метод гусеницы}

Метод гусеницы (SSA) в базовом варианте состоит в ~\cite{Book1}:
\begin{enumerate}
\item развертка одномерного ряда в многомерный;
\item анализ главных компонент: сингулярное разложение выборочной ковариационной матрицы;
\item отбор главных компонент;
\item восстановление одномерного ряда.
\end{enumerate}

Применив метод Гусеницы к исходному ряду, получим ряд, разложенный на простые компоненты. В результате это разложение может служить основой прогнозирования как самого ряда, так и его отдельных составляющих.

Рассмотрим временной ряд ${x_i}^{N}_{i=1}$, образованный последовательностью $N$ значений некоторой (вероятно, случайной) функции $f(t)$:

$$x_i = f((i-1)\delta t), $$

где $i=1,2,…,N$.

В действительности, существует несколько вариантов алгоритма, Опишем в этой работе один из них:

\subsection{Развертка одномерного ряда в многомерный}

Пусть есть некоторое число $M<N$ , представляющее длину гусеницы, и положим первые $M$ значений последовательности $f$ в качестве первой строки матрицы $X$ . Второй строкой матрицы будут являться значения последовательности с $x_2$ по $x_{M+1}$. Последней строкой с номером $k = N - M + 1$ будут последние $M$ членов исходной последовательности. Получившуюся матрицу, элементы которой представляются как $x_{ij} = x_{i+j-1}$, можно рассматривать как $M$ - мерную выборку объема $k$ или $M$ - мерный временной ряд, которому соответствует $M$ - мерная траектория (ломаная в $M$ - мерном пространстве из $k-1$ звена.

Далее по обычной схеме (но без стандартизации признаков) выполняется анализ главных компонент (АГК).

\subsection{Анализ главных компонент: сингулярное разложение
выборочной ковариационной матрицы}

Первым делом, вычисляется матрица $V = (1/k)X^{T}X$. Мы будем называть ее ковариационной матрицей, несмотря на то, что ее элементы не центрированы, иногда добавляя слово "нецентральная".

Далее, как обычно в АГК, вычисляются собственные числа и вектора матрицы $V$ , т.е. разложение ее $V = P\Lambda P^T$, где $\Lambda$ - это диагональная матрица, на диагонали которой стоят собственные числа, упорядоченные по убыванию, а $P$ - ортогональная матрица собственных векторов матрицы $V$.

Матрицы $L$ и $P$ совместно имеют множество интерпретаций, основанных на АГК. Будем рассматривать матрицу $P$ как матрицу перехода к главным компонентам $XP = Y = (y1,y2,...,y_M)$.

В случае, если изучается выборка из случайной совокупности, то собственные числа матрицы $V$ являются выборочными дисперсиями соответствующих главных компонент, а квадратные корни из них - выборочными стандартами. Графическое представление собственных чисел и некоторых функций от них в АГК традиционно используется для выявления структуры исследуемой совокупности и отбора и интерпретации главных компонент.

Заметим также, что при выборе длины гусеницы, равной $N-M+1$ , собственные вектора и главные компоненты просто меняются местами с точностью до нормировки.

\subsection{Отбор главных компонент}

В силу свойств матрицы $P$ возможно представить матрицу ряда $X$ как $X = Y P^T$. Таким образом, мы получаем разложение матрицы ряда по ортогональным составляющим, а именно - главным компонентам.

В то же время преобразование $y_j = X p_j$ является линейным преобразованием исходного процесса с помощью дискретного оператора свертки, т.е.

$$y_j [l] = \sum^{M}_{q=1}{x_{lq} p_{jq}}=\sum^{M}_{q=1}{x_{l+q-1} p_{jq}}.$$

Таким образом, процедура "Гусеница" представляет собой набор линейных фильтров, настроенных на составляющие исходного ряда. При этом собственные векторы матрицы $V$ выступают в качестве переходных функций соответствующих фильтров.

Аналитическое и визуальное изучение собственных векторов и главных компонент, полученных в результате линейной фильтрации, может дать много интересной информации о структуре изучаемого процесса и свойствах составляющих его слагаемых.

В частности, среди главных компонент можно выделить:
\begin{enumerate}
\item относящиеся к тренду (медленно меняющиеся);
\item периодические;
\item шумовые.
\end{enumerate}

Крайне эффективным выходит изучение построенных графиков изучение двумерных графиков, аналогичных фигурам Лиссажу, когда по осям x и y откладываются различные пары собственных векторов или главных компонент. Известно, что, если по осям откладывать значения синусоиды одной и той же той же частоты, но с разными фазами, то на плоскости получается эллипс. Из того факта, что собственные вектора и главные компоненты ортогональны следует, что фазовый сдвиг между такими парами наверняка будет равен $\pm\pi/2$ и, таким образом, эллипс переходит в окружность.

\subsection{Восстановление одномерного ряда}

Заключительным и наиболее важным этапом метода "Гусеница" является процедура восстановления. Этот этап основан на разложении $X = Y P^T$. Восстановление проводится по данному набору главным компонентам, если при применении формулы восстановления $X = Y\* P^T$ матрица $Y\*$ получена из матрицы $Y$ обнулением всех не входящих в набор главных компонент. Таким образом, становится возможным получить интересующее нас приближение матрицы ряда или интерпретируемую часть этой матрицы.

Переход к восстановленному ряду возможно осуществить усреднением матрицы ряда по побочным диагоналям, но в этом случае возможно некоторое искажение полученной структуры.

Отметим сразу одну очень важную в этой работе отличительную особенность описанного метода - его интерактивность. То есть возможность реализовать общение пользователя и программы. Интерактивность метода связана с типично статистическим свойством алгоритма, а именно, необходимостью интерпретации промежуточных результатов и управлением выполнения алгоритма в процессе многоэтапной процедуры обработки. Однако, несмотря на это преимущество, оно нам не потребуется. Анализ полученных данных будет производиться посредством изучения визуальной модели.

Из-за высокой точности динамики получаемых моделей воспользуемся методом Гусеницы в качестве основного метода для анализа данных воспользуемся именно им.

\section{Выводы по разделу 1}%section
В первом разделе мы ближе познакомились с предметом последующего изучения в этой работе.

Были рассмотрены виды акций и образование их стоимости. Также были рассмотрены биржи и, в частности, рассмотрена корейская биржа, на которой и будет базироваться исследование, проводимое в этой выпускной квалификационной работе.

В главе также были рассмотрены методы прогнозирования и анализа временных рядов. Было решено преимущественно использовать метод гусеницы для анализа временного ряда по причине высокой точности к прогнозированию динамики временного ряда.

\zerocounters

\chapter*{\thechapter. Разработка приложения и анализ и прогнозирование цен акций}\addcontentsline{toc}{section}{\hspace{-1.2cm} \thechapter. РАЗРАБОТКА ПРИЛОЖЕНИЯ И ПРОГНОЗИРОВАНИЕ ЦЕН АКЦИЙ}

\section{Выбор средств разработки}%section

Для разработки аналитического приложения, способного самостоятельно собирать данные с интернет-ресурса в режиме реального времени нужна развитая платформа с большим набором инструментов. Для этих целей как раз подходит платформа Microsoft .Net Framework. Эта платформа реализует большой инструментарий для работы как с анализируемыми данными, так и с более абстрагированными объектами.

\subsection{Язык C\#, платформа .Net Framework}

На сегодняшний день язык программирования C\# и платформа .Net Framework являются одними из наиболее популярных инструментов у разработчиков по всему миру. На этой платформе можно реализовать совершенно разные решения: от простейших консольных программ до сложнейших научных библиотек и микросервисов в веб-стеке ~\cite{Inet source6}.

Язык проектировался как полностью объектно-ориентированный, и его компания-разработчик Microsoft всегда выделяет это свойство языка в качестве его главных преимуществ. Ещё одним преимуществом является сравнительно низкий порог входа, обеспечивая вместе с тем большую потенциальную мощность разрабатываемых приложений.

Ещё одним преимуществом языка C\# и платформы .Net Framework является развитое сообщество. Этот факт выводит возможности встроенного пакетного менеджера NuGet на новый уровень: любой желающий может разработать своё собственное решение задачи и загрузить его на сервер Microsoft в открытый доступ. В данной работе воспользуемся этой возможностью и загрузим библиотеки как необходимые для дальнейшей работы, так и упрощающие реализацию некоторых решений.

\subsection{Библиотеки}

В разработанном приложении использованы следующие библиотеки:
\begin{enumerate}
\item HtmlAgilityPack. Данный пакет позволяет получать html-код веб-страницы и предлагает удобные методы для парсинга DOM-дерева с помощью XPath-строки ~\cite{Inet source2};
\item MathNet. Пакет, в котором реализованы объекты для работы с линейной алгеброй, статистикой, теорией вероятностей и некоторые другие а также методы для работы с ними. Также реализована перегрузка операторов для новых типов данных. Воспользуемся данным пакетом для работы с матрицами в методе Гусеницы ~\cite{Inet source4};
\item Стандартные библиотеки .Net Framework. Среди таких библиотек есть библиотеки для ~\cite{Inet source5}:
 \begin{enumerate}
 \item сериализации (чтения и записи) собранных данных в .json-файл для дальнейшей работы с ними;
 \item работы со стандартными коллекциями, такими как список;
 \item получения необходимой выборки из стандартных коллекций и их сортировки;
 \item работы с WinForms.
 \end{enumerate}
\end{enumerate}

\subsection{Система контроля версий Git}

Система контроля версий — это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии.

Ядро Git представляет собой набор команд для командной строки с параметром. Все настройки хранятся в текстовых файлах. Такая система позволяет сделать Git легко портируемым на любую платформу и легко интегрировать в любую систему.

Система имеет низкий порог входа для пользователей, предлагая управление файлами как с помощью командной строки, так и с помощью различных пользовательских интерфейсов. Справедливо будет сказать, что низкий порог входа обеспечивается преимущественно для людей, достаточно глубоко знакомых с информационными технологиями, в то время как остальным нужно будет потратить больше времени и усилий, чтобы понять, как работать с Git.

Основной концепцией для понимания работы с Git является разделения рабочего пространства на 3 условных зоны (~\ref{rls:git-stages}).

\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{git-stages.PNG}
\caption{Рабочее пространство Git}
\label{rls:git-stages}
\end{figure}

В качестве первой зоны выступает рабочий каталог (Working directory). Он представляет собой буквально каталог, в котором мы работаем и вносим изменения в существующие файлы, удаляем их или создаём новые.

Внеся необходимые изменения, мы выбираем интересующие нас файлы. Таким образом, файлы попадают в промежуточную зону (Staging area).

Когда выбор файлов окончен, изменения фиксируются, и оказываются в репозитории (Git repository).

Репозиторий Git представляет собой каталог на диске, содержащий файлы проекта и файлы конфигурации. Сам репозиторий может быть на удалённый сервер после вносимых изменений для возможности работы на разных устройствах и для повышения безопасности во избежания непредвиденных обстоятельств, связанных с аппаратной частью компьютера.

Управление изменениями и репозиторием происходит посредством текстовых команд из командного окна: "git add", "git commit", "git push", "git pull" и так далее. Пример представлен на рисунке ~\ref{rls:git}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{git.PNG}
\caption{Командное окно Git Bash}
\label{rls:git}
\end{figure}

\newpage

Также Git поддерживает ветвление. То есть, возможно создание ветки от определённой фиксации (коммита) для внесения тематических изменений. При таком подходе в определённый момент образуется множество параллельных веток, несущих разные изменения. Все эти изменения возможно объединить посредством слияния (merge). Слияние пройдёт в автоматическом режиме в том случае, если в файлах нет конфликтов изменений. В случае возникновения таких конфликтов необходимо будет вручную их разрешить, оставив желаемые изменения, после чего зафиксировать результат слияния.

\section{Написание алгоритма работы программы}%section
Для разработки приложения, которое будет самостоятельно собирать данные с удалённых источников и в последствии их анализировать, необходимо реализовать следующие возможности:
\begin{enumerate}
\item сбор данных непосредственно с удалённой веб-страницы;
\item сериализация собранных данных;
\item асинхронное чтение собранных ранее данных и запись их в память;
\item прогноз будущих значений;
\item отображение полученных данных на пользовательской форме.
\end{enumerate}

Приложение разработано под ОС Windows, для запуска необходимо выполнить исполняемый файл. 

При запуске программы инициализируется пользовательская форма. При нажатии на кнопку "Начать" начинается цикл сбора данных.

Программа каждую минуту параллельно начинает попытки подключения к сайту Investing.com. Получив страницу, приложение использует X-Path строку для выделения нужной информации о цене акций и состоянии площадки.

После получения цены на акции происходит запись в .json-файл всего списка значений, а также добавление полученного значения в сам список.

Далее, когда данные собраны, при построении графика, данные читаются из файла, и на их основе строится два графика: с исходным рядом и прогнозируемым.
 
Блок-схема рабочего цикла представлена на рисунке ~\ref{rls:algorithm}.

\begin{figure}[h]
\centering
\includegraphics[width=0.17\linewidth]{algorithm.PNG}
\caption{Основной алгоритм программы}
\label{rls:algorithm}
\end{figure}

\newpage

\subsection{Проектирование внутренней структуры, применение паттернов разработки}

Основной рабочей структурой в программе являются аналитические модули. Они организованы в соответствии с паттерном проектирования "фабричный метод". На языке диаграмм UML можно представить структуру следующим образом (~\ref{rls:PredictorFactoryUml}).

\begin{figure}[h]
\centering
\includegraphics[width=1.0\linewidth]{PredictorFactoryUml.PNG}
\caption{Описание паттерна проектирования «фабричный метод»}
\label{rls:PredictorFactoryUml}
\end{figure}

\subsection{Разработка аналитических модулей}

В программе имеется три аналитических модуля, спроектированных по паттерну разработки «фабричный метод» реализующие различные прогнозирующие методы:
\begin{enumerate}
\item метод простого скользящего среднего;
\item метод авторегрессионного скользящего среднего;
\item метод гусеницы.
\end{enumerate}

Доступ к модулям осуществляется из класса-сборщика PredictorFactory. На вход помещается временной ряд, требуемая точность прогнозирования и тип прогнозирующего метода.

Далее, в зависимости от типа, выбирается соответствующий метод, и ему в обработку передаётся временной ряд и заданная точность.

\section{Разработка пользовательского интерфейса}

Для базового управления процессом и вывода результатов пользователю используется технология WinForms. 

Для построения пользовательской формы были использованы стандартные компоненты, предлагаемые .Net Framework:
\begin{enumerate}
\item кнопки;
\item текстовое поле;
\item график;
\item выпадающий список;
\item текстовая подпись.
\end{enumerate}

Элементы были скомпонированы на форме для максимально удобного пользования приложением и для удобства просмотра информации.

\section{Выводы по разделу 2}
Из обзора видно, что необходима платформа, которая сможет совместить в себе возможность получения информации из интернет-ресурсов и мощные аналитические инструменты для работы с собранными данными.

В качестве платформы для разработки был выбран язык программирования C\# на платформе .Net Framework, так как он отвечает всем необходимым требованиям.

Также важным этапом разработки является версионный контроль для сохранения данных и восстановления их в случае утери. Сегодня версионный контроль представляет неотъемлимую часть разработки и используется опытными разработчиками на любых проектах, вне зависимости от их масштаба.

Основным методом для анализа данных был выбран метод Гусеницы ввиду высокой точности прогнозируемой динамики на большом масштабе, в чём ему методы простого и авторегрессионного скользящего среднего проигрывают.

В результате было разработано приложение, следящее за изменением цен на акции «Samsung Electronics Co.», и анализирующее собранные результаты тремя разным различными методами.

\zerocounters
\chapter*{\thechapter. Анализ и прогнозирование данных}\addcontentsline{toc}{section}{\hspace{-1.2cm} \thechapter. АНАЛИЗ И ПРОГНОЗИРОВАНИЕ ДАННЫХ }

\section{Реализация аналитических модулей}

Для реализации описанных выше методов был создан ряд классов, отражающих сущности операций и математических объектов. Классы организованы по шаблону проектирования «фабричный метод». В этом случае вызов нужного метода располагается в реализующем его классе и проходит через транзитный класс, определяющий используемый метод анализа на основе входящего параметра, определяющего тип метода для анализа.

\subsection{Блок-схема аналитических модулей}

На блок-схеме (~\ref{rls:analitycsAlgorithm}) можно увидеть процесс поступления на обработку данных, процесса выбора нужного метода прогнозирования и возврата прогнозируемого значения.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\linewidth]{analitycsAlgorithm.PNG}
\caption{"Блок-схема работы аналитических модулей"}
\label{rls:analitycsAlgorithm}
\end{figure}

\newpage

\subsection{Пример работы программы}

При запуске программа инициализирует форму, заполняет внутренний список значений из прилагающегося .json-файла с данными, собранными ранее, если таковые имеются. Инициализировавшись, форма приобретает следующий вид(рис. ~\ref{rls:example}):

\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{example.PNG}
\caption{"Главная форма программы"}
\label{rls:example}
\end{figure}

В правой части программы располагается место под график на основе уже собранных данных. Выпадающий список предлагает выбрать метод прогнозирования, по умолчанию это простое скользящее среднее. После выбора графика необходимо нажать на прилагающую кнопку, чтобы построить график. Пример на изображён на рисунке ~\ref{rls:example1}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{example1.PNG}
\caption{"Пример построения графика"}
\label{rls:example1}
\end{figure}

\newpage

Для того, чтобы построить новый график, необходимо в выпадающем списке выбрать интересующую модель и снова нажать на кнопку "Построить график".

\section{Анализ стоимостей акций «Samsung Electronics Co.»}

Анализ стоимостей акций показал, что наиболее эффективным методом оказался метод "Гусеницы", который выполняет построение максимально точно к исходному ряду. Пример такого построения изображён на рисунке ~\ref{rls:ssa}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{ssa.PNG}
\caption{График, основанный на модели «Гусеница»}
\label{rls:ssa}
\end{figure}

На графике видно, что построенная модель практически полностью перекрывает исходный ряд, что говорит о её высоком качестве. Такая близость значений объясняется преимущественно линейным поведением временного ряда в исследуемый промежуток. Не исключено, что при более резкий колебаниях значений расхождения были бы более существенны.

\section{Прогнозирование динамики изменения цен акций «Samsung Electronics Co.»}

Для прогнозирования будущих значений ряда можно воспользоваться любым из описанных в предыдущей главе методом. Возьмём данные, собранные на торгах за 20 июня 2019 года. В качестве метода прогнозирования воспользуемся методом простого скользящего среднего, потому как этот метод наиболее прост в программной реализации и цель состоит в краткосрочном прогнозе динамики. Воспользуемся собранными значениями для прогнозирования данных (рисунок ~\ref{rls:predict}):
\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{predict.PNG}
\caption{График спрогнозированной динамики изменения цен на акции «Samsung Electronics Co.»}
\label{rls:predict}
\end{figure}

\newpage

Сравним результаты с техническим анализом на сайте Investing.com (рисунок ~\ref{rls:investing}).
\begin{figure}[h]
\centering
\includegraphics[width=0.5\linewidth]{investing.PNG}
\caption{Технический анализ от сайта Investing.com}
\label{rls:investing}
\end{figure}

\newpage

Как видно, данные полностью совпадают, что говорит о том, что сервис Investing.com действительно использует методы простого скользящего среднего для прогноза будущих значений.

\section{Выводы по разделу 3}

В этом разделе было рассмотрено разработанное для целей данной работы приложение. Показаны примеры работы приложения на собранных данных с сайта Investing.com.

В результате анализа данных был построен прогноз с помощью метода простого скользящего среднего. Сравнение построенного прогноза с имеющимся на сайте Investing.com показало, что наш прогноз полностью соответствует таковому на сайте.

\zerocounters
\chapter*{Заключение}\addcontentsline{toc}{section}{\hspace{-0.9cm} ЗАКЛЮЧЕНИЕ }
Данная выпускная квалификационная работа посвящена всегда актуальной теме исследования временных рядов на примере цен акций на основе собранных данных.

Целью работы являлось построение прогноза динамики изменения цен на акции «Samsung Electronics Co.».

В соответствии с целью были рассмотрены варианты методов прогнозирования и реализовано приложение, способное в автономном режиме собирать актуальные данные и анализировать их. В результате сбора и анализа данных был построен собственный прогноз, полностью совпадающий с таковым на сайте Investing.com.

В первой главе была рассмотрена общая информация об изучаемой компании, акциях, формировании на них цен и биржах. Также в главе были рассмотрены методы прогнозирования и анализа данных. Для анализа было решено использовать метод Гусеницы по причине высокой точности к прогнозированию динамики.

Во втором разделе был построен алгоритм работы программы и разработана математическая модель взаимодействия программных компонентов между собой. Также было построено приложение для сбора данных, их последующего анализа, прогнозирования будущих значений на основе уже собранных и визуализации полученных данных.

В третьей главе было подробно рассмотрено приложение и его возможности, и с помощью реализации был проведён анализ собранных данных о ценах акций «Samsung Electronics Co.». Также был построен прогноз на основе модели простого скользящего среднего в разном диапазоне. Выявлено, что на сайте Investing.com используются те же инструменты для прогнозирования, что и описанные в этой работе.

В результате разработки было получено простое в использовании приложение, позволяющее:
\begin{enumerate}
\item автономно собирать информацию о состоянии площадки;
\item получать и записывать информацию об изменениях цен на акции;
\item проводить различные типы анализа данных;
\item выводить на график результаты анализа.
\end{enumerate}

В ходе работы были решены следующие задачи:
\begin{enumerate}
\item выполнен обзор существующих методов прогнозирования;
\item разработан алгоритм работы программы;
\item разработан способ сериализации данных для последующего чтения;
\item реализован пользовательский интерфейс;
\item реализовано отображение данных.
\end{enumerate}

Таким образом, все поставленные цели были достигнуты. В дальнейшем планируется добавление и реализация новых методов прогнозирования в программу и расширение функционала.

\input{biblio}

\zerocounters
\newpage
\chapter*{Приложение 1}\addcontentsline{toc}{section}{\hspace{-1.2cm} ПРИЛОЖЕНИЕ 1 }
\textbf{Form1.cs}
\begin{verbatim}
using HtmlAgilityPack;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows.Forms.DataVisualization.Charting;
using HtmlDocument = HtmlAgilityPack.HtmlDocument;
using System.Runtime.Serialization.Json;
using System.Threading;
using MetalParser.Predicting;
using System.Linq;
using MathNet.Numerics.Statistics;

namespace MetalParser
{
    public partial class Form1 : Form
    {
        System.Windows.Forms.Timer tSamsung = new System.Windows.Forms.Timer();
        int timeout = 60000;

        string platinum_path = "@/data/platinum-cfd.txt";
        string gold_path = "@/data/gold-cfd.txt";
        string silver_path = "@/data/silver-cfd.txt";
        string samsung_path = "@/data/Samsung-electronincs-Co.txt";
        string samsungJsonData = "@/data/samsung.json";
        string apple_path = "@/data/Apple.txt";

        List<double> platinumValues = new List<double>();
        List<double> goldValues = new List<double>();
        List<double> silverValues = new List<double>();
        List<Data> samsungValues = new List<Data>();
        List<double> appleValues = new List<double>();

        public Form1()
        {
            InitializeComponent();
        }

        private async Task<string> FindValue(string Url, Object sender, EventArgs e)
        {
            string parsedValue = null;
            CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
            CancellationToken token = cancelTokenSource.Token;
            await Task.Run(async () =>
            {
                try
                {
                    HtmlWeb web = new HtmlWeb();
                    HtmlDocument doc = web.Load(Url);
                    if (doc != null)
                    {
                        string openState = doc.DocumentNode.SelectNodes("//*[@id=\"quotes_summary_current_data\"]/div[1]/div[2]/div[2]/text()")[2].InnerText;
                        parsedValue = openState.ToLower().Contains("закрыт") ? "closed" : doc.DocumentNode.SelectNodes("//*[@id='last_last']")[0].InnerText;
                        if (parsedValue == "closed")
                        {
                            cancelTokenSource.Cancel();
                        }
                    }
                }
                catch (Exception ex)
                {
                    parsedValue = "lost connection";
                }
            });
            if(cancelTokenSource.IsCancellationRequested)
            {
                tSamsung.Interval = timeout * 10; //Уменьшение частоты проверки в случае закрытой биржи до 10 минут
                return null;
            }
            return parsedValue;
        }

        /// <summary>
        /// Метод асинхронно получает значение акции и записывает его в файл
        /// </summary>
        /// <param name="url">Ссылка на страницу со значением стоимости акции</param>
        private async void GetValue(string url, Object sender, EventArgs e)
        {
            string value = await FindValue(url, sender, e);
            DateTime date = DateTime.Now;
            if (value == null)
            {
                textBox1.Text += $"{date.ToString("dd.MM.yy hh:mm")} | Торги закрыты.{Environment.NewLine}";
                return;
            }

            value = value.Replace(".", "");
            string line = $"{date.ToString("dd.MM.yy hh:mm")} | {value}";

            if (value != "lost connection")
            {
                Data data = new Data(date, Double.Parse(value));
                samsungValues.Add(data);
                WriteValue(samsungJsonData, data);
            }

            textBox1.Text += line + Environment.NewLine;
        }

        /// <summary>
        /// Пишет полученное значение в json-файл
        /// </summary>
        /// <param name="path">Путь к json-файлу</param>
        /// <param name="data">Дата и цена акции</param>
        private void WriteValue(string path, Data data)
        {
            List<Data> values = ReadValues(path);
            values.Add(data);

            using (FileStream fs = new FileStream(samsungJsonData, FileMode.OpenOrCreate))
            {
                DataContractJsonSerializer jsonFormatter = new DataContractJsonSerializer(typeof(List<Data>));
                jsonFormatter.WriteObject(fs, values);
            }
        }

        /// <summary>
        /// Читает json-файл со значениями даты и цены и возвращает список
        /// </summary>
        /// <param name="path">Путь к json-файлу</param>
        /// <returns></returns>
        private List<Data> ReadValues(string path)
        {
            List<Data> valuesList = new List<Data>();
            DataContractJsonSerializer jsonFormatter = new DataContractJsonSerializer(typeof(List<Data>));
            using (FileStream fs = new FileStream(path, FileMode.OpenOrCreate))
            {
                List<Data> dataList = jsonFormatter.ReadObject(fs) as List<Data>;

                foreach (Data data in dataList)
                {
                    valuesList.Add(data);
                }
            }

            return valuesList;
        }

        private void button1_Click(object sender, EventArgs e)
        {
            button1.Enabled = false;
            button2.Enabled = true;

            tSamsung.Interval = timeout;
            tSamsung.Tick += (timer, arguments) => GetValue(samsungUrl, sender, e);
            tSamsung.Start();
        }

        private void button2_Click(object sender, EventArgs e)
        {
            button1.Enabled = true;
            button2.Enabled = false;
            tSamsung.Stop();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            try
            {
                comboBox1.SelectedIndex = 0;
                //При загрузке формы читаем файл и заполняем список значениями из него
                foreach(Data data in ReadValues(samsungJsonData))
                {
                    samsungValues.Add(data);
                }
            }
            catch(Exception ex)
            {

            }
        }

        private void label1_Click(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {

        }

        private void button3_Click(object sender, EventArgs e)
        {
            bar.ChartAreas.Clear();
            bar.ChartAreas.Add(new ChartArea("Time series"));
            Series series = new Series("Original");
            series.ChartType = SeriesChartType.Line;
            for (int i = 0; i < samsungValues.Count; i++)
            {
                series.Points.AddXY(samsungValues[i].Date, samsungValues[i].Value);
            }

            int option = comboBox1.SelectedIndex;
            PredictorFactory predictorFactory = null;
            switch (option)
            {
                case 0:
                    predictorFactory = new PredictorFactory(PredictorTypes.MA);
                    break;

                case 1:
                    predictorFactory = new PredictorFactory(PredictorTypes.ARMA);
                    break;

                case 2:
                    predictorFactory = new PredictorFactory(PredictorTypes.SSA);
                    break;
            }

            Series estimation = new Series("Estimated");
            estimation.ChartType = SeriesChartType.Line;
            List<Double?> predictedValues = new List<Double?>();
            int accuracy = 10;
            if (predictorFactory.Type == PredictorTypes.MA)
            {
                List<Double> predictedValues1 = new List<double>();
                for (int i = 0; i < samsungValues.Count; i++)
                {
                    predictedValues1.Add(samsungValues[i].Value);
                }
                List<Double> copy = MAPredictor.PredictList(predictedValues1, accuracy);

                for (int i = 0; i < samsungValues.Count; i++)
                {
                    estimation.Points.AddXY(samsungValues[i].Date, copy[i]);
                }
            }
            else if (predictorFactory.Type == PredictorTypes.ARMA)
            {
                List<Double> copy = new List<Double>();
                for (int i = 0; i < samsungValues.Count; i++)
                {
                    copy.Add(samsungValues[i].Value);
                }

                List<Double> prediction = ARMAPredictor.PredictList(copy, accuracy);

                for (int i = 0; i < samsungValues.Count; i++)
                {
                    estimation.Points.AddXY(samsungValues[i].Date, prediction[i]);
                }
            }
            else if (predictorFactory.Type == PredictorTypes.SSA)
            {
                List<Double> temp = new List<Double>();
                for (int i = 0; i < samsungValues.Count; i++)
                {
                    temp.Add(samsungValues[i].Value);
                }
                List<double> predictedValues1 = SSAPredictor.PredictList(temp, 10);
                for (int i = 0; i < samsungValues.Count; i++)
                {
                    estimation.Points.AddXY(samsungValues[i].Date, predictedValues1[i]);
                }
            }

            bar.ChartAreas[0].AxisY.Minimum = 970;

            bar.Series.Clear();
            bar.Series.Add(series);
            bar.Series.Add(estimation);
        }

        private void ComboBox1_SelectedIndexChanged(object sender, EventArgs e)
        {
            panel1.Visible = comboBox1.SelectedIndex == 0;
            button4.Visible = comboBox1.SelectedIndex == 0;
        }

        private void Button4_Click(object sender, EventArgs e)
        {
            bar.ChartAreas.Clear();
            bar.ChartAreas.Add(new ChartArea("Time series"));
            Series series = new Series("Original");
            series.ChartType = SeriesChartType.Line;
            Series estimation = new Series("Estimated");
            estimation.ChartType = SeriesChartType.Line;

            List<Double> values = new List<Double>();
            for (int i = 0; i < samsungValues.Count; i++)
            {
                series.Points.AddXY(samsungValues[i].Date, samsungValues[i].Value);
                values.Add(samsungValues[i].Value);
            }

            List<Double> estimated = values.MovingAverage(200).ToList<Double>();
            DateTime date = samsungValues[0].Date;
            for (int i = 0; i < samsungValues.Count + 200; i++)
            {
                if (i < 200)
                    estimation.Points.AddXY(date, values[i]);
                else
                    estimation.Points.AddXY(date, estimated[i-200]);

                date = date.AddMinutes(1);
            }

            MA5.Text = $"MA5 - {values.MovingAverage(5).ToList<Double>()[values.Count - 1].ToString()}";
            MA10.Text = $"MA10 - {values.MovingAverage(10).ToList<Double>()[values.Count - 1].ToString()}";
            MA20.Text = $"MA20 - {values.MovingAverage(20).ToList<Double>()[values.Count - 1].ToString()}";
            MA50.Text = $"MA50 - {values.MovingAverage(50).ToList<Double>()[values.Count - 1].ToString()}";
            MA100.Text = $"MA100 - {values.MovingAverage(100).ToList<Double>()[values.Count - 1].ToString()}";
            MA200.Text = $"MA200 - {values.MovingAverage(200).ToList<Double>()[values.Count - 1].ToString()}";

            bar.ChartAreas[0].AxisY.Minimum = 970;

            bar.Series.Clear();
            bar.Series.Add(series);
            bar.Series.Add(estimation);
        }
    }
}
\end{verbatim}

\textbf{PredictorFactory.cs}
\begin{verbatim}
using System;
using System.Collections.Generic;

namespace MetalParser.Predicting
{
    class PredictorFactory
    {
        public PredictorTypes Type;

        public PredictorFactory(PredictorTypes type)
        {
            Type = type;
        }

        public double? PredictValue(List<Double> values, int accuracy)
        {
            double? predictedValue = null;

            switch (Type)
            {
                case (PredictorTypes.MA):
                    predictedValue = MAPredictor.Predict(values, accuracy);
                    break;

                case (PredictorTypes.ARMA):
                    predictedValue = ARMAPredictor.Predict(values, accuracy);
                    break;

                case (PredictorTypes.SSA):
                    predictedValue = SSAPredictor.Predict(values, accuracy);
                    break;
            }

            return predictedValue;
        }
    }
}
\end{verbatim}

\textbf{PredictorTypes.cs}
\begin{verbatim}
namespace MetalParser.Predicting
{
    enum PredictorTypes
    {
        MA,
        ARMA,
        SSA
    }
}
\end{verbatim}

\textbf{MAPredictor.cs}
\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.Statistics;

namespace MetalParser.Predicting
{
    class MAPredictor
    {
        /// <summary>
        /// Predicts next number using MA methond with defined accuracy
        /// </summary>
        /// <param name="values">Time series</param>
        /// <param name="accuracy">Number of last items in time series</param>
        /// <returns></returns>
        public static double Predict(List<Double> values, int accuracy)
        {
            Double maSum = 0;
            int window = values.Count / accuracy;

            for (int i = values.Count - 1; i > window; i--)
            {
                maSum += values[i];
            }
            return maSum/accuracy;
        }

        public static List<Double> PredictList(List<Double> values, int accuracy)
        {
            var a = values.MovingAverage(accuracy);
            return a.ToList<Double>();
        }
    }
}
\end{verbatim}

\textbf{ARMAPredictor.cs}
\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.Distributions;
using MathNet.Numerics.Statistics;

namespace MetalParser.Predicting
{
    class ARMAPredictor
    {
        public static double Predict(List<Double> values, int accuracy)
        {

            double epsilon = Normal.Sample(0.0, values.StandardDeviation());
            double X = epsilon + MAPredictor.Predict(values, accuracy) + ARModel(values, 2);

            return X;
        }

        public static List<Double> PredictList(List<Double> values, int accuracy)
        {
            List<Double> result = new List<Double>();
            int parameter = 2;
            double[] coefficients = GetCoefficients(values, parameter);
            List<Double> maModel = MAPredictor.PredictList(values, accuracy);

            for (int i = 0; i < values.Count; i++)
            {
                double epsilon = Normal.Sample(0.0, values.StandardDeviation());
                double sum = 0;
                for (int j = 0; j < parameter; j++)
                {
                    if (i >= parameter)
                    {
                        sum += values[i - j] * coefficients[parameter - j - 1];
                        sum += sum == 0 ? 0 : 490;
                    }
                    else
                    {
                        sum = values[i];
                        break;
                    }
                }
                result.Add(epsilon + (sum + maModel[i])/2.0);
            }

            return result;
        }

        private static double StandardDeviation(List<Double> values) //Sample Variance i.e. standard deviation
        {
            Double mean = values.Sum() / values.Count;
            List<Double> squaredDiff = new List<Double>(values.Count);
            for (int i = 0; i < values.Count; i++)
            {
                squaredDiff[i] = Math.Pow((values[i] - mean), 2.0);
            }

            return squaredDiff.Sum()/values.Count;
        }

        private static double[] GetCoefficients(List<Double> values, int parameter)
        {
            double result = 0.0;
            double[] coefficients = new double[parameter];

            //Coefficients evaluation
            for (int i = 0; i < coefficients.Count(); i++)
            {
                double upper = 0.0;
                double lower = 0.0;

                for (int j = i + 1; j < parameter; j++)
                {
                    upper += (values[values.Count - j] - values.Mean()) * (values[values.Count - j - i] - values.Mean());

                }
                for (int j = 0; j < parameter; j++)
                {
                    lower += Math.Pow(values[values.Count - j - 1] - values.Mean(), 2.0);
                }

                coefficients[i] = upper / lower;
            }

            return coefficients;
        }

        private static double ARModel(List<Double> values, int parameter)
        {
            double[] coefficients = GetCoefficients(values, parameter);
            double result = 0;

            for (int i = 0; i < parameter; i++)
            {
                result += values[values.Count - i - 1] * coefficients[parameter - i - 1];
            }

            return result;
        }
    }
}
\end{verbatim}

\textbf{SSAPredictor.cs}
\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Double;
using MathNet.Numerics.LinearAlgebra.Factorization;

namespace MetalParser.Predicting
{
    class SSAPredictor
    {
        private static int L = 150;
        private static int K;

        public static double Predict(List<Double> values, int accuracy)
        {
            return Reconstruct(values, accuracy)[0];
        }

        public static List<Double> PredictList(List<Double> values, int accuracy)
        {
            List<Double> orig = new List<Double>(values);
            List<Double> rec = new List<Double>(Reconstruct(values, accuracy).ToList());

            for (int i = 0; i < values.Count; i++)
            {
                rec[i] = rec[i] * 10 + orig[i];
            }
            return rec;
        }

        private static Matrix<Double> BuildTrayectoryMatrix(List<Double> values)
        {
            int N = values.Count;
            //if (L > N / 2)
            //    L = (N * 4)/10;

            K = N - L + 1;
            Matrix<Double> X = DenseMatrix.Create(K, L, 0);

            for (int i = 0; i < K; i++) //Rows
            {
                for (int j = 0; j < L; j++) //Cols
                {
                    if (i + j <= values.Count - 1)
                        X[i, j] = values[i + j];
                }
            }

            return X;
        }

        private static Matrix<Double> SVD(List<Double> values, int accuracy) //Singular Value Decomposition
        {
            Matrix<Double> X = BuildTrayectoryMatrix(values);

            Matrix<Double> V = X.Transpose() * X;
            Svd<Double> svd = V.Svd(true);
            Matrix<Double> U = svd.VT;
            Matrix<Double> rca = U * V.Inverse();

            return rca;
        }

        private static Vector<Double> Reconstruct(List<Double> values, int accuracy)
        {
            int N = values.Count;
            Matrix<Double> rca = SVD(values, accuracy);
            Vector<Double> y = DenseVector.Create(N, 0.0);
            int Lp = Math.Max(L, K);
            int Kp = Math.Min(L, K);

            for (int k = 0; k < Kp; k++)
            {
                for (int m = 1; m < k; m++)
                {
                    y[k + 1] += /*(1 / (Double.Parse(k.ToString()) + 1)) **/ rca[m, k - m];
                }
            }

            for (int k = Lp - 1; k < Kp - 1; k++)
            {
                for (int m = 1; m < Lp; m++)
                {
                    y[k + 1] += /*(1 / Double.Parse(Lp.ToString())) **/ rca[m, k - m];
                }
            }

            for (int k = Kp; k < N; k++)
            {
                for (int m = k - Kp + 2; m < N - Lp; m++)
                {
                    y[k + 1] += /*(1 / Double.Parse((N - K).ToString())) **/ rca[m, k - m];
                }
            }

            return y;
        }
    }
}
\end{verbatim}

\textbf{Data.cs}
\begin{verbatim}
using System;
using System.Runtime.Serialization;

namespace MetalParser
{
    [DataContract]
    class Data
    {
        [DataMember]
        public DateTime Date { get; set; }
        [DataMember]
        public Double Value { get; set; }

        public Data(DateTime date, Double value)
        {
            Date = date;
            Value = value;
        }
    }
}
\end{verbatim}

\textbf{Program.cs}
\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MetalParser
{
    static class Program
    {
        /// <summary>
        /// Главная точка входа для приложения.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
\end{verbatim}

\textbf{Form1.Designer.cs}
\begin{verbatim}
namespace MetalParser
{
    partial class Form1
    {
        /// <summary>
        /// Обязательная переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором форм Windows

        /// <summary>
        /// Требуемый метод для поддержки конструктора — не изменяйте
        /// содержимое этого метода с помощью редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea2 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();
            System.Windows.Forms.DataVisualization.Charting.Legend legend2 = new System.Windows.Forms.DataVisualization.Charting.Legend();
            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.button3 = new System.Windows.Forms.Button();
            this.bar = new System.Windows.Forms.DataVisualization.Charting.Chart();
            this.comboBox1 = new System.Windows.Forms.ComboBox();
            this.label2 = new System.Windows.Forms.Label();
            this.panel1 = new System.Windows.Forms.Panel();
            this.MA5 = new System.Windows.Forms.Label();
            this.MA10 = new System.Windows.Forms.Label();
            this.MA20 = new System.Windows.Forms.Label();
            this.MA50 = new System.Windows.Forms.Label();
            this.MA100 = new System.Windows.Forms.Label();
            this.MA200 = new System.Windows.Forms.Label();
            this.button4 = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.bar)).BeginInit();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            //
            // button1
            //
            this.button1.Location = new System.Drawing.Point(12, 33);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 1;
            this.button1.Text = "Начать";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            //
            // button2
            //
            this.button2.Enabled = false;
            this.button2.Location = new System.Drawing.Point(94, 32);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(75, 23);
            this.button2.TabIndex = 2;
            this.button2.Text = "Закончить";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            //
            // textBox1
            //
            this.textBox1.AcceptsReturn = true;
            this.textBox1.AcceptsTab = true;
            this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
            | System.Windows.Forms.AnchorStyles.Left)));
            this.textBox1.ImeMode = System.Windows.Forms.ImeMode.On;
            this.textBox1.Location = new System.Drawing.Point(13, 81);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.ReadOnly = true;
            this.textBox1.Size = new System.Drawing.Size(258, 335);
            this.textBox1.TabIndex = 3;
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(10, 65);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(51, 13);
            this.label1.TabIndex = 4;
            this.label1.Text = "Samsung";
            this.label1.Click += new System.EventHandler(this.label1_Click);
            //
            // button3
            //
            this.button3.Location = new System.Drawing.Point(277, 55);
            this.button3.Name = "button3";
            this.button3.Size = new System.Drawing.Size(121, 23);
            this.button3.TabIndex = 19;
            this.button3.Text = "Построить график";
            this.button3.UseVisualStyleBackColor = true;
            this.button3.Click += new System.EventHandler(this.button3_Click);
            //
            // bar
            //
            chartArea2.Name = "ChartArea1";
            this.bar.ChartAreas.Add(chartArea2);
            legend2.Name = "Legend1";
            this.bar.Legends.Add(legend2);
            this.bar.Location = new System.Drawing.Point(277, 81);
            this.bar.Name = "bar";
            this.bar.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Bright;
            series2.ChartArea = "ChartArea1";
            series2.Legend = "Legend1";
            series2.Name = "Time Series";
            this.bar.Series.Add(series2);
            this.bar.Size = new System.Drawing.Size(630, 335);
            this.bar.TabIndex = 20;
            this.bar.Text = "chart1";
            //
            // comboBox1
            //
            this.comboBox1.Cursor = System.Windows.Forms.Cursors.Hand;
            this.comboBox1.FormattingEnabled = true;
            this.comboBox1.Items.AddRange(new object[] {
            "MA",
            "ARMA",
            "SSA"});
            this.comboBox1.Location = new System.Drawing.Point(405, 55);
            this.comboBox1.Name = "comboBox1";
            this.comboBox1.Size = new System.Drawing.Size(121, 21);
            this.comboBox1.TabIndex = 21;
            this.comboBox1.SelectedIndexChanged += new System.EventHandler(this.ComboBox1_SelectedIndexChanged);
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(402, 38);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(108, 13);
            this.label2.TabIndex = 22;
            this.label2.Text = "Модель построения";
            //
            // panel1
            //
            this.panel1.Controls.Add(this.MA200);
            this.panel1.Controls.Add(this.MA100);
            this.panel1.Controls.Add(this.MA50);
            this.panel1.Controls.Add(this.MA20);
            this.panel1.Controls.Add(this.MA10);
            this.panel1.Controls.Add(this.MA5);
            this.panel1.Location = new System.Drawing.Point(620, 3);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(260, 75);
            this.panel1.TabIndex = 23;
            this.panel1.Visible = false;
            //
            // MA5
            //
            this.MA5.AutoSize = true;
            this.MA5.Location = new System.Drawing.Point(4, 4);
            this.MA5.Name = "MA5";
            this.MA5.Size = new System.Drawing.Size(29, 13);
            this.MA5.TabIndex = 0;
            this.MA5.Text = "MA5";
            //
            // MA10
            //
            this.MA10.AutoSize = true;
            this.MA10.Location = new System.Drawing.Point(4, 29);
            this.MA10.Name = "MA10";
            this.MA10.Size = new System.Drawing.Size(35, 13);
            this.MA10.TabIndex = 1;
            this.MA10.Text = "MA10";
            //
            // MA20
            //
            this.MA20.AutoSize = true;
            this.MA20.Location = new System.Drawing.Point(4, 52);
            this.MA20.Name = "MA20";
            this.MA20.Size = new System.Drawing.Size(35, 13);
            this.MA20.TabIndex = 2;
            this.MA20.Text = "MA20";
            //
            // MA50
            //
            this.MA50.AutoSize = true;
            this.MA50.Location = new System.Drawing.Point(137, 4);
            this.MA50.Name = "MA50";
            this.MA50.Size = new System.Drawing.Size(35, 13);
            this.MA50.TabIndex = 3;
            this.MA50.Text = "MA50";
            //
            // MA100
            //
            this.MA100.AutoSize = true;
            this.MA100.Location = new System.Drawing.Point(137, 29);
            this.MA100.Name = "MA100";
            this.MA100.Size = new System.Drawing.Size(41, 13);
            this.MA100.TabIndex = 4;
            this.MA100.Text = "MA100";
            //
            // MA200
            //
            this.MA200.AutoSize = true;
            this.MA200.Location = new System.Drawing.Point(137, 52);
            this.MA200.Name = "MA200";
            this.MA200.Size = new System.Drawing.Size(41, 13);
            this.MA200.TabIndex = 5;
            this.MA200.Text = "MA200";
            //
            // button4
            //
            this.button4.Location = new System.Drawing.Point(536, 12);
            this.button4.Name = "button4";
            this.button4.Size = new System.Drawing.Size(82, 23);
            this.button4.TabIndex = 24;
            this.button4.Text = "Прогноз";
            this.button4.UseVisualStyleBackColor = true;
            this.button4.Click += new System.EventHandler(this.Button4_Click);
            //
            // Form1
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.SystemColors.GradientInactiveCaption;
            this.ClientSize = new System.Drawing.Size(919, 428);
            this.Controls.Add(this.button4);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.comboBox1);
            this.Controls.Add(this.bar);
            this.Controls.Add(this.button3);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.button1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.Shown += new System.EventHandler(this.Form1_Load);
            ((System.ComponentModel.ISupportInitialize)(this.bar)).EndInit();
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button button3;
        private System.Windows.Forms.DataVisualization.Charting.Chart bar;
        private System.Windows.Forms.ComboBox comboBox1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Label MA200;
        private System.Windows.Forms.Label MA100;
        private System.Windows.Forms.Label MA50;
        private System.Windows.Forms.Label MA20;
        private System.Windows.Forms.Label MA10;
        private System.Windows.Forms.Label MA5;
        private System.Windows.Forms.Button button4;
    }
}
\end{verbatim}

\end{document} 